#pragma once

#include "deegen_common_utils.h"

namespace deegen
{

// The type of a field in a bytecode op
//
enum class BytecodeFieldKind
{
    // Just a simple field
    //
    SimpleField,
    // An array with constant (i.e., same for all bytecodes of this type) length
    //
    FixLenArray,
    // An array with variable length, where the length is indicated by another uint32_t field
    //
    VarLenArray
};

class EightByteBox
{
protected:
    uint64_t m_dummy;
};
static_assert(sizeof(EightByteBox) == 8);

class SixteenByteBox
{
protected:
    uint64_t m_dummy[2];
};
static_assert(sizeof(SixteenByteBox) == 16);

constexpr size_t x_config_box_size = 8;
static_assert(x_config_box_size == 8 || x_config_box_size == 16);

class BoxedValue : public std::conditional_t<x_config_box_size == 8, EightByteBox, SixteenByteBox>
{

};
static_assert(sizeof(BoxedValue) == x_config_box_size);

// A reference (use-edge) to a bytecode.
// Note that we require bytecode in SSA form, so the referenced bytecode must be
// a dominator of the current bytecode in the SSA graph.
//
class BytecodeRef
{
public:
    // Get the SSA value generated by the bytecode
    //
    BoxedValue GetValue() const noexcept;

private:
    uint64_t m_dummy;
};
static_assert(sizeof(BytecodeRef) == 8);

// A branch target that one can transfer control to
// Passed as parameter to 'BranchToBytecode' to transfer control to that bytecode
//
class BytecodeDest
{
protected:
    uint64_t m_dummy;
};
static_assert(sizeof(BytecodeDest) == 8);

void NO_RETURN BranchToBytecode(BytecodeDest dest) noexcept;
void NO_RETURN BranchToNextBytecode() noexcept;

struct BytecodeFieldMetadata
{
    constexpr BytecodeFieldMetadata(BytecodeFieldKind fieldKind,
                                    const char* fieldName,
                                    std::string_view typeName,
                                    uint32_t arrayFixedLength,
                                    const char* arrayVarLengthFieldName)
        : m_fieldKind(fieldKind)
        , m_fieldName(fieldName)
        , m_typeName(typeName)
        , m_arrayFixedLength(arrayFixedLength)
        , m_arrayVarLengthFieldName(arrayVarLengthFieldName)
    { }

    static constexpr BytecodeFieldMetadata WARN_UNUSED CreateSimpleField(const char* fieldName,
                                                                         std::string_view typeName)
    {
        return BytecodeFieldMetadata(BytecodeFieldKind::SimpleField,
                                     fieldName,
                                     typeName,
                                     0 /*arrayFixedLength*/,
                                     nullptr /*arrayVarLengthFieldName*/);
    }

    static constexpr BytecodeFieldMetadata WARN_UNUSED CreateFixLenArrayField(const char* fieldName,
                                                                              std::string_view typeName,
                                                                              uint32_t arrayLength)
    {
        ReleaseAssert(arrayLength > 0);
        return BytecodeFieldMetadata(BytecodeFieldKind::FixLenArray,
                                     fieldName,
                                     typeName,
                                     arrayLength,
                                     nullptr /*arrayVarLengthFieldName*/);
    }

    static constexpr BytecodeFieldMetadata WARN_UNUSED CreateVarLenArrayField(const char* fieldName,
                                                                              std::string_view typeName,
                                                                              const char* lengthFieldName)
    {
        return BytecodeFieldMetadata(BytecodeFieldKind::VarLenArray,
                                     fieldName,
                                     typeName,
                                     0 /*arrayFixedLength*/,
                                     lengthFieldName);

    }

    // The kind of this field
    //
    BytecodeFieldKind m_fieldKind;
    // The name of this field
    //
    const char* m_fieldName;
    // The typename of this field
    //
    std::string_view m_typeName;
    // If the field is FixLenArray, the length of the array
    //
    uint32_t m_arrayFixedLength;
    // If the field is VarLenArray, the name of the field that indicates the length
    //
    const char* m_arrayVarLengthFieldName;
};

template<typename T>
struct BytecodeMetadataAccessor
{
    constexpr static size_t
        numFields = T::template __deegen_internal<T::__deegen_internal_anchor::value>::N;

    constexpr static std::array<BytecodeFieldMetadata, numFields>
        mdArray = T::template __deegen_internal<T::__deegen_internal_anchor::value>::get();
};

// A user bytecode op must use the following pattern to declare fields in the struct:
//
//   BEGIN_FIELD_LIST();
//   ... list of fields ...
//   END_FIELD_LIST();
//
// Each field may be one of the following:
//
//   FIELD(name, type):
//       Declares a simple field 'name' of type 'type'. e.g.,
//           FIELD(foo, int)
//       The field may then be accessed by calling foo()
//
//   FIELD_ARR_FIXLEN(name, length_literal, type):
//       Declares an array field of fixed length. e.g.,
//           FIELD_ARR_FIXLEN(foo, 10, int)
//       The field may then be accessed by calling foo(index)
//
//   FIELD_ARR_VARLEN(name, length_name, type):
//       Declares two fields:
//       (1) An array field 'name' of variable length, as specified by 'length_name'.
//       (2) An uint32_t field 'length_name' of type uint32_t.
//       Example:
//           FIELD_ARR_FIXLEN(foo, bar, int)
//       The field may then be accessed by calling foo(index),
//       and the field length may be accessed by calling bar()
//

// Specializing using __COUNTER__ is tricky because we may create different definitions
// in different translation units (C++ files), thus violating one-definition rule.
//
// However, this is safe in our specific use case: according to C++ standard, symbols
// for constexpr values are only emitted if they are used by a non-constexpr expression.
// The __deegen_internal_anchor_start class is not used by anything that is not constexpr.
// Therefore, no information about this __deegen_internal_anchor_start class will be
// emitted into the object files, so no observable ODR violations will happen.
//
#define BEGIN_FIELD_LIST_IMPL_(counter_)                                                \
    struct __deegen_internal_anchor_start {                                             \
        constexpr static size_t value = counter_;                                       \
    };                                                                                  \
                                                                                        \
    template<int __deegen_internal_ord>                                                 \
    struct __deegen_internal : __deegen_internal<__deegen_internal_ord - 1> {};         \
                                                                                        \
    template<> struct __deegen_internal<0>                                              \
    {                                                                                   \
        constexpr static size_t N = 0;                                                  \
        constexpr static std::array<::deegen::BytecodeFieldMetadata, N> get()           \
        {                                                                               \
            return std::array<::deegen::BytecodeFieldMetadata, N>{};                    \
        }                                                                               \
    }

#define BEGIN_FIELD_LIST() BEGIN_FIELD_LIST_IMPL_(__COUNTER__)

#define DEEGEN_INSERT_BYTECODE_METADATA(counter_, ...)                                      \
    template<> struct __deegen_internal<counter_ - __deegen_internal_anchor_start::value>   \
    {                                                                                       \
        constexpr static int p = counter_ - __deegen_internal_anchor_start::value - 1;      \
        constexpr static size_t N = __deegen_internal<p>::N + 1;                            \
        constexpr static std::array<::deegen::BytecodeFieldMetadata, N> get()               \
        {                                                                                   \
            return ::deegen::constexpr_std_array_concat(                                    \
                __deegen_internal<p>::get(),                                                \
                std::array<::deegen::BytecodeFieldMetadata, 1>{                             \
                    __VA_ARGS__                                                             \
                }                                                                           \
            );                                                                              \
        }                                                                                   \
    }

#define FIELD_IMPL_(counter_, name_, type_)                                             \
    type_ WARN_UNUSED name_() const noexcept;                                           \
    DEEGEN_INSERT_BYTECODE_METADATA(counter_,                                           \
        ::deegen::BytecodeFieldMetadata::CreateSimpleField(                             \
            #name_ ,                                                                    \
            __stringify_type__< type_ >()))

#define FIELD(name_, type_) FIELD_IMPL_(__COUNTER__, name_, type_)

#define FIELD_ARR_FIXLEN_IMPL_(counter_, name_, len_, type_)                            \
    type_ WARN_UNUSED name_(uint32_t /*index*/) const noexcept;                         \
    DEEGEN_INSERT_BYTECODE_METADATA(counter_,                                           \
        ::deegen::BytecodeFieldMetadata::CreateFixLenArrayField(                        \
            #name_ ,                                                                    \
            __stringify_type__< type_ >(),                                              \
            (len_) ))

#define FIELD_ARR_FIXLEN(name_, len_, type_) FIELD_ARR_FIXLEN_IMPL_(__COUNTER__, name_, len_, type_)

#define FIELD_ARR_VARLEN_IMPL_(counter1_, counter2_, name_, len_name_, type_)           \
    uint32_t WARN_UNUSED len_name_() const noexcept;                                    \
    type_ WARN_UNUSED name_(uint32_t /*index*/) const noexcept;                         \
    DEEGEN_INSERT_BYTECODE_METADATA(counter1_,                                          \
        ::deegen::BytecodeFieldMetadata::CreateVarLenArrayField(                        \
            #name_ ,                                                                    \
            __stringify_type__< type_ >(),                                              \
            #len_name_ ));                                                              \
    DEEGEN_INSERT_BYTECODE_METADATA(counter2_,                                          \
        ::deegen::BytecodeFieldMetadata::CreateSimpleField(                             \
            #len_name_ ,                                                                \
            __stringify_type__<uint32_t>()))

#define FIELD_ARR_VARLEN(name_, len_name_, type_) FIELD_ARR_VARLEN_IMPL_(__COUNTER__, __COUNTER__, name_, len_name_, type_)

#define END_FIELD_LIST_IMPL_(counter_)                                                  \
    struct __deegen_internal_anchor {                                                   \
        constexpr static int value = counter_ - __deegen_internal_anchor_start::value;  \
    }

#define END_FIELD_LIST() END_FIELD_LIST_IMPL_(__COUNTER__)

}   // namespace deegen
