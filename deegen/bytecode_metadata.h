#pragma once

#include "deegen_common_utils.h"
#include "user_type_definitions.h"

namespace deegen
{

// The type of a field in a bytecode op
//
enum class BytecodeFieldKind
{
    // Just a simple field
    //
    SimpleField,
    // An array with constant (i.e., same for all bytecodes of this type) length
    //
    FixLenArray,
    // An array with variable length, where the length is indicated by another uint32_t field
    //
    VarLenArray
};

class EightByteBox
{
protected:
    uint64_t m_dummy;
};
static_assert(sizeof(EightByteBox) == 8);

class SixteenByteBox
{
protected:
    uint64_t m_dummy[2];
};
static_assert(sizeof(SixteenByteBox) == 16);

constexpr size_t x_config_box_size = 8;
static_assert(x_config_box_size == 8 || x_config_box_size == 16);

class BoxedValue : public std::conditional_t<x_config_box_size == 8, EightByteBox, SixteenByteBox>
{

};
static_assert(sizeof(BoxedValue) == x_config_box_size);

// A reference (use-edge) to a bytecode.
// Note that we require bytecode in SSA form, so the referenced bytecode must be
// a dominator of the current bytecode in the SSA graph.
//
class BytecodeRef
{
public:
    // Get the SSA value generated by the bytecode
    //
    BoxedValue GetValue() const noexcept;

private:
    uint64_t m_dummy;
};
static_assert(sizeof(BytecodeRef) == 8);

// A branch target that one can transfer control to
// Passed as parameter to 'BranchToBytecode' to transfer control to that bytecode
//
class BytecodeDest
{
protected:
    uint64_t m_dummy;
};
static_assert(sizeof(BytecodeDest) == 8);

void NO_RETURN BranchToBytecode(BytecodeDest dest) noexcept;
void NO_RETURN BranchToNextBytecode() noexcept;

struct BytecodeFieldMetadata
{
    constexpr BytecodeFieldMetadata(BytecodeFieldKind fieldKind,
                                    const char* fieldName,
                                    std::string_view typeName,
                                    uint32_t arrayFixedLength,
                                    const char* arrayVarLengthFieldName)
        : m_fieldKind(fieldKind)
        , m_fieldName(fieldName)
        , m_typeName(typeName)
        , m_arrayFixedLength(arrayFixedLength)
        , m_arrayVarLengthFieldName(arrayVarLengthFieldName)
    { }

    static constexpr BytecodeFieldMetadata WARN_UNUSED CreateSimpleField(const char* fieldName,
                                                                         std::string_view typeName)
    {
        return BytecodeFieldMetadata(BytecodeFieldKind::SimpleField,
                                     fieldName,
                                     typeName,
                                     0 /*arrayFixedLength*/,
                                     nullptr /*arrayVarLengthFieldName*/);
    }

    static constexpr BytecodeFieldMetadata WARN_UNUSED CreateFixLenArrayField(const char* fieldName,
                                                                              std::string_view typeName,
                                                                              uint32_t arrayLength)
    {
        ReleaseAssert(arrayLength > 0);
        return BytecodeFieldMetadata(BytecodeFieldKind::FixLenArray,
                                     fieldName,
                                     typeName,
                                     arrayLength,
                                     nullptr /*arrayVarLengthFieldName*/);
    }

    static constexpr BytecodeFieldMetadata WARN_UNUSED CreateVarLenArrayField(const char* fieldName,
                                                                              std::string_view typeName,
                                                                              const char* lengthFieldName)
    {
        return BytecodeFieldMetadata(BytecodeFieldKind::VarLenArray,
                                     fieldName,
                                     typeName,
                                     0 /*arrayFixedLength*/,
                                     lengthFieldName);

    }

    // The kind of this field
    //
    BytecodeFieldKind m_fieldKind;
    // The name of this field
    //
    const char* m_fieldName;
    // The typename of this field
    //
    std::string_view m_typeName;
    // If the field is FixLenArray, the length of the array
    //
    uint32_t m_arrayFixedLength;
    // If the field is VarLenArray, the name of the field that indicates the length
    //
    const char* m_arrayVarLengthFieldName;
};

template<typename T>
struct BytecodeMetadataAccessor
{
    constexpr static size_t
        numFields = T::template __deegen_internal<T::__deegen_internal_anchor::value>::N;

    constexpr static std::array<BytecodeFieldMetadata, numFields>
        mdArray = T::template __deegen_internal<T::__deegen_internal_anchor::value>::get();
};

// A user bytecode op must use the following pattern to declare fields in the struct:
//
//   BEGIN_FIELD_LIST();
//   ... list of fields ...
//   END_FIELD_LIST();
//
// Each field may be one of the following:
//
//   FIELD(name, type):
//       Declares a simple field 'name' of type 'type'. e.g.,
//           FIELD(foo, int)
//       The field may then be accessed by calling foo()
//
//   FIELD_ARR_FIXLEN(name, length_literal, type):
//       Declares an array field of fixed length. e.g.,
//           FIELD_ARR_FIXLEN(foo, 10, int)
//       The field may then be accessed by calling foo(index)
//
//   FIELD_ARR_VARLEN(name, length_name, type):
//       Declares two fields:
//       (1) An array field 'name' of variable length, as specified by 'length_name'.
//       (2) An uint32_t field 'length_name' of type uint32_t.
//       Example:
//           FIELD_ARR_FIXLEN(foo, bar, int)
//       The field may then be accessed by calling foo(index),
//       and the field length may be accessed by calling bar()
//

// Specializing using __COUNTER__ is tricky because we may create different definitions
// in different translation units (C++ files), thus violating one-definition rule.
//
// However, this is safe in our specific use case: according to C++ standard, symbols
// for constexpr values are only emitted if they are used by a non-constexpr expression.
// The __deegen_internal_anchor_start class is not used by anything that is not constexpr.
// Therefore, no information about this __deegen_internal_anchor_start class will be
// emitted into the object files, so no observable ODR violations will happen.
//
#define BEGIN_FIELD_LIST_IMPL_(counter_)                                                \
    struct __deegen_internal_anchor_start {                                             \
        constexpr static size_t value = counter_;                                       \
    };                                                                                  \
                                                                                        \
    template<int __deegen_internal_ord>                                                 \
    struct __deegen_internal : __deegen_internal<__deegen_internal_ord - 1> {};         \
                                                                                        \
    template<> struct __deegen_internal<0>                                              \
    {                                                                                   \
        constexpr static size_t N = 0;                                                  \
        constexpr static std::array<::deegen::BytecodeFieldMetadata, N> get()           \
        {                                                                               \
            return std::array<::deegen::BytecodeFieldMetadata, N>{};                    \
        }                                                                               \
    }

#define BEGIN_FIELD_LIST() BEGIN_FIELD_LIST_IMPL_(__COUNTER__)

#define DEEGEN_INSERT_BYTECODE_METADATA(counter_, ...)                                      \
    template<> struct __deegen_internal<counter_ - __deegen_internal_anchor_start::value>   \
    {                                                                                       \
        constexpr static int p = counter_ - __deegen_internal_anchor_start::value - 1;      \
        constexpr static size_t N = __deegen_internal<p>::N + 1;                            \
        constexpr static std::array<::deegen::BytecodeFieldMetadata, N> get()               \
        {                                                                                   \
            return ::deegen::constexpr_std_array_concat(                                    \
                __deegen_internal<p>::get(),                                                \
                std::array<::deegen::BytecodeFieldMetadata, 1>{                             \
                    __VA_ARGS__                                                             \
                }                                                                           \
            );                                                                              \
        }                                                                                   \
    }

#define FIELD_IMPL_(counter_, name_, type_)                                             \
    type_ WARN_UNUSED name_() const noexcept;                                           \
    DEEGEN_INSERT_BYTECODE_METADATA(counter_,                                           \
        ::deegen::BytecodeFieldMetadata::CreateSimpleField(                             \
            #name_ ,                                                                    \
            __stringify_type__< type_ >()))

#define FIELD(name_, type_) FIELD_IMPL_(__COUNTER__, name_, type_)

#define FIELD_ARR_FIXLEN_IMPL_(counter_, name_, len_, type_)                            \
    type_ WARN_UNUSED name_(uint32_t /*index*/) const noexcept;                         \
    DEEGEN_INSERT_BYTECODE_METADATA(counter_,                                           \
        ::deegen::BytecodeFieldMetadata::CreateFixLenArrayField(                        \
            #name_ ,                                                                    \
            __stringify_type__< type_ >(),                                              \
            (len_) ))

#define FIELD_ARR_FIXLEN(name_, len_, type_) FIELD_ARR_FIXLEN_IMPL_(__COUNTER__, name_, len_, type_)

#define FIELD_ARR_VARLEN_IMPL_(counter1_, counter2_, name_, len_name_, type_)           \
    uint32_t WARN_UNUSED len_name_() const noexcept;                                    \
    type_ WARN_UNUSED name_(uint32_t /*index*/) const noexcept;                         \
    DEEGEN_INSERT_BYTECODE_METADATA(counter1_,                                          \
        ::deegen::BytecodeFieldMetadata::CreateVarLenArrayField(                        \
            #name_ ,                                                                    \
            __stringify_type__< type_ >(),                                              \
            #len_name_ ));                                                              \
    DEEGEN_INSERT_BYTECODE_METADATA(counter2_,                                          \
        ::deegen::BytecodeFieldMetadata::CreateSimpleField(                             \
            #len_name_ ,                                                                \
            __stringify_type__<uint32_t>()))

#define FIELD_ARR_VARLEN(name_, len_name_, type_) FIELD_ARR_VARLEN_IMPL_(__COUNTER__, __COUNTER__, name_, len_name_, type_)

#define END_FIELD_LIST_IMPL_(counter_)                                                  \
    struct __deegen_internal_anchor {                                                   \
        constexpr static int value = counter_ - __deegen_internal_anchor_start::value;  \
    }

#define END_FIELD_LIST() END_FIELD_LIST_IMPL_(__COUNTER__)

// Macro REGISTER_DISPATCHER(class_name, method_name, template_param_count)
// Register a type dispatcher templated member function
// The templated function being registered must look like the following:
//    template<TypeEnum... te_list>
//    Ret method_name(Type<te_list>*... te_vals, Args... arg_vals)
//
// The macro generates another member function
//    Ret dispatch_to_##method_name(BoxedValue... bv_vals, Args... arg_vals)
//
// The generated function has the following semantics:
//    (1) bv_vals are unboxed to TypeEnum list 'te_list' and value list 'te_vals'
//    (2) method_name<te_list> is invoked with parameter te_vals, arg_vals
//
#define REGISTER_DISPATCHER(classname, methodname, num_template_params)                             \
    constexpr void __deegen_internal_assert_class_ ## methodname () {                               \
        static_assert(std::is_same_v<std::remove_pointer_t<decltype(this)>, classname>,             \
            "wrong classname '" #classname "' is provided to REGISTER_DISPATCHER macro");           \
    }                                                                                               \
                                                                                                    \
    template<size_t __n, ::deegen::TypeEnum... __tes>                                               \
    struct __gen_list_impl_ ## methodname                                                           \
    {                                                                                               \
        template<size_t __i>                                                                        \
        constexpr static auto __exec()                                                              \
        {                                                                                           \
            if constexpr(sizeof...(__tes) == __n)                                                   \
            {                                                                                       \
                /* TODO: add static_assert to check that function shape is good */                  \
                return std::make_tuple(& classname :: methodname <__tes...>);                       \
            }                                                                                       \
            else if constexpr(__i + 1 >= static_cast<size_t>(::deegen::TypeEnum::X_END_OF_ENUM))    \
            {                                                                                       \
                return __gen_list_impl_ ## methodname <                                             \
                            __n, __tes..., static_cast<::deegen::TypeEnum>(__i)>::                  \
                                template __exec<0>();                                               \
            }                                                                                       \
            else                                                                                    \
            {                                                                                       \
                return std::tuple_cat(                                                              \
                    __gen_list_impl_ ## methodname <                                                \
                            __n, __tes..., static_cast<::deegen::TypeEnum>(__i)>::                  \
                                template __exec<0>(),                                               \
                    __gen_list_impl_ ## methodname <__n, __tes...>::                                \
                                template __exec<__i + 1>()                                          \
                );                                                                                  \
            }                                                                                       \
        }                                                                                           \
    };                                                                                              \
                                                                                                    \
    constexpr static auto __gen_list_ ## methodname()                                               \
    {                                                                                               \
        constexpr auto res = __gen_list_impl_ ## methodname < num_template_params >::__exec<0>();   \
        return res;                                                                                 \
    }                                                                                               \
                                                                                                    \
    static void __attribute__((__used__))                                                           \
        __gen_voidstar_list_ ## methodname(std::vector<void*>* output /*out*/)                      \
    {                                                                                               \
        constexpr auto res = __gen_list_ ## methodname();                                           \
        ::deegen::ConvertPointerTupleToVoidStarVector(res, output /*out*/);                         \
    }                                                                                               \
                                                                                                    \
    template<int __N, ::deegen::TypeEnum... __S>                                                    \
    struct __instantiate_helper : __instantiate_helper<                                             \
        __N - 1, static_cast<::deegen::TypeEnum>(0), __S...> { };                                   \
                                                                                                    \
    template<::deegen::TypeEnum... __S>                                                             \
    struct __instantiate_helper<0, __S...>                                                          \
    {                                                                                               \
        using type = decltype(&classname :: methodname <__S...>);                                   \
    };                                                                                              \
                                                                                                    \
    using __function_type_ ## methodname =                                                          \
        typename __instantiate_helper<num_template_params>::type;                                   \
                                                                                                    \
    static_assert(::deegen::is_member_function_const<__function_type_ ## methodname>::value,        \
        "function '" #methodname "' provided to REGISTER_DISPATCHER must be const");                \
    static_assert(::deegen::is_member_function_noexcept<__function_type_ ## methodname>::value,     \
        "function '" #methodname "' provided to REGISTER_DISPATCHER must be noexcept");             \
                                                                                                    \
    using __return_type_ ## methodname =                                                            \
        ::deegen::member_function_return_type_t <                                                   \
            __function_type_ ## methodname >;                                                       \
                                                                                                    \
    template<typename __T> struct __deegen_internal_dispatch_ ## methodname;                        \
                                                                                                    \
    template<typename... __Args>                                                                    \
    struct __deegen_internal_dispatch_ ## methodname<                                               \
        __return_type_ ## methodname( classname ::* )(__Args...) const noexcept>                    \
    {                                                                                               \
        static_assert(std::is_same_v<                                                               \
            __return_type_ ## methodname( classname ::* )(__Args...) const noexcept,                \
            __function_type_ ## methodname>,                                                        \
            "dispatch_" #methodname " is called with incompatible function parameters");            \
                                                                                                    \
        template<size_t __i>                                                                        \
        using DispatcherArgType = std::conditional_t<                                               \
            __i < num_template_params,                                                              \
            ::deegen::BoxedValue,                                                                   \
            std::tuple_element_t<__i, std::tuple<__Args...>>>;                                      \
                                                                                                    \
        template<int __N, int... __S>                                                               \
        struct impl : impl<__N - 1, __N - 1, __S...> { };                                           \
                                                                                                    \
        template<int... __S>                                                                        \
        struct impl<0, __S...>                                                                      \
        {                                                                                           \
            /* implementation intentionally not provided so we can identify it in LLVM IR */        \
            static __return_type_ ## methodname __dispatcher_run__(                                 \
                std::add_pointer_t< std::add_const_t< classname > >,                                \
                DispatcherArgType<__S>...) noexcept;                                                \
        };                                                                                          \
                                                                                                    \
        using impl_t = impl<sizeof...(__Args)>;                                                     \
    };                                                                                              \
                                                                                                    \
    template<typename... __Args>                                                                    \
    __return_type_ ## methodname __attribute__((__always_inline__))                                 \
        dispatch_to_ ## methodname(__Args&&... __args) const noexcept                               \
    {                                                                                               \
        using __impl = typename __deegen_internal_dispatch_ ## methodname<                          \
                    __function_type_ ## methodname>::impl_t;                                        \
        __impl::__dispatcher_run__(this, std::forward<__Args>(__args)...);                          \
    }

}   // namespace deegen
